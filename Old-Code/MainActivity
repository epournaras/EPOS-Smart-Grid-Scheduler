import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.support.v4.app.DialogFragment;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;

import com.example.activitieslibrary.Activities;
import com.example.activitieslibrary.Schedule;
import com.example.activitieslibrary.ScheduleList;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.Character;
import java.util.ArrayList;
import java.util.Random;

import static java.util.Arrays.sort;

public class MainActivity extends AppCompatActivity {
    public String selectedActiv;
    //create a list in which to store the Activities in a list for later use.
    int listSize = 3;
    public Activities[] list = new Activities[listSize];
    //create the storage so that objects can be passed from one activity or fragment to the next
    public static String MY_PREFS = "MY_PREFS";
    int prefMode = Activity.MODE_PRIVATE;
    //create the Schedule item list to use to display assess inputs.
    public ScheduleList itemList = new ScheduleList();
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        try{
         setContentView(R.layout.activity_main);
            itemList = itemList.createList();
            //create the list of activities available to select from.
            String[] ActivArr = {"cooking", "shower", "charging car"};
            int[] ActivMins = {30,10,120};
            Activities cooking = new Activities();
            cooking = cooking.createActivity(ActivArr[0],ActivMins[0],true);
            list[0] = cooking;
            Activities shower = new Activities();
            shower = shower.createActivity(ActivArr[1],ActivMins[1],true);
            list[1] = shower;
            Activities chargingCar = new Activities();
            chargingCar = chargingCar.createActivity(ActivArr[2],ActivMins[2],false);
            list[2] = chargingCar;
            ArrayAdapter<CharSequence> adapterActiv;
            Spinner activDrp = (Spinner) findViewById(R.id.spActiv);
            adapterActiv = new ArrayAdapter<CharSequence>(this, android.R.layout.simple_spinner_item, ActivArr);
            adapterActiv.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
            activDrp.setAdapter(adapterActiv);
            selectedActiv = activDrp.getSelectedItem().toString();
        }catch(NullPointerException ex){
            ex.printStackTrace();
        }
    }
    //to indicate whether the time being selected is a min or max, "min" or "max" is sent to the timeFragment to tell it where to store the input.
    public void showTimePickerDialogMin(View v) {
        try{
            FileOutputStream fosThree = openFileOutput("minOrMax.txt", Context.MODE_PRIVATE);
            fosThree.write("min".getBytes());
            DialogFragment newFragment = new timeFragment();
            newFragment.show(getSupportFragmentManager(), "timeFragment");
        }catch(IOException ex){
            ex.printStackTrace();
        }
    }
    //to indicate whether the time being selected is a min or max, "min" or "max" is sent to the timeFragment to tell it where to store the input.
    public void showTimePickerDialogMax(View v) {
        try{
            FileOutputStream fosThree = openFileOutput("minOrMax.txt", Context.MODE_PRIVATE);
            fosThree.write("max".getBytes());
            DialogFragment newFragment = new timeFragment();
            newFragment.show(getSupportFragmentManager(), "timeFragment");
        }catch(IOException ex){
            ex.printStackTrace();
        }
    }
    //adds an item to the schedule list.
    public void addItem(View v){
       //input test:
        try{
            Spinner activDrp = (Spinner) findViewById(R.id.spActiv);
            selectedActiv = activDrp.getSelectedItem().toString();
            FileInputStream fisGetFiles = openFileInput("firstAction.txt");
            String name = selectedActiv+","; // , seperates items in the file.

            StringBuilder builder = new StringBuilder();
            int cha;
            while((cha = fisGetFiles.read())!=-1){
                builder.append((char)cha);
            }
            String test = builder.toString();
            //Get the last entered time window.
            fisGetFiles = openFileInput("tempMin.txt");
            builder = new StringBuilder();
            int chr;
            while((chr = fisGetFiles.read())!=-1){
                builder.append((char)chr);
            }
            String tempMin = builder.toString();
            fisGetFiles = openFileInput("tempMax.txt");
            builder = new StringBuilder();
            int ch;
            while((ch = fisGetFiles.read())!=-1){
                builder.append((char)ch);
            }
            String tempMax = builder.toString();

            Random gen = new Random();
            double priority = gen.nextDouble(); //randomly generate a priority for testing
            Activities toSubmit = new Activities();

            for(int i = 0;i<listSize;i++)
                if(selectedActiv.equals(list[i].name)) toSubmit = list[i];

            Schedule newItem = new Schedule();
            newItem = newItem.createSchedule(toSubmit,tempMin,tempMax,priority);

            if(itemList.addScheduleItem(newItem)){
                //ToDo add successfully added message.
            }
            else{
                //ToDo create error message.
            }

        }catch(IOException ex){
            ex.printStackTrace();
        }
    }
    //Switches to the screen to display the items added and their time windows.
    public void sendMessage(View view) {
        /*
        create schedule arrangements from list, pick one, send it on to the display.
        Prepare it for display by 1) Taking the activity names and placing them in order (lowest min time at start) in nameOfAction. 2) organise minTimes and maxTimes so the minTime of nameOfAction in position 0
        is in minTime position 0 and the maxTime of nameOfAction in position 0 is in maxTimes position 0.
        */
        try {
            String displayName = "";
            String displayMaxTime = "";
            String displayMinTime = "";
            FileOutputStream fosInput = openFileOutput("nameOfAction.txt", Context.MODE_PRIVATE);
            Schedule[][]arrangementsList = itemList.createPossibleLists(); //create all possible arrangements

            Random rand =  new Random();
            int min = 0;
            int max = arrangementsList.length;
            int randArrangement  = rand.nextInt((max - min)) + min;

            //select a random arrangement from the list and display it.

            int[] indiciesInOrder = new int[arrangementsList[randArrangement].length];
            int[] minTimesInOrder = new int[arrangementsList[randArrangement].length];

            for(int i = 0; i<arrangementsList[randArrangement].length; i++){
                minTimesInOrder[i] = arrangementsList[randArrangement][i].minTime;
            }
            sort(minTimesInOrder);

            for(int o = 0; o<minTimesInOrder.length;o++) {
                boolean found = false;
                for (int k = 0; k < arrangementsList[randArrangement].length && !found; k++) {
                    if(minTimesInOrder[o]==arrangementsList[randArrangement][k].minTime){
                        indiciesInOrder[o] = k;
                        found = true;
                    }
                }
            }
            for(int i = 0; i<arrangementsList[randArrangement].length; i++){
               displayName += arrangementsList[randArrangement][indiciesInOrder[i]].activity.name+",";
               displayMaxTime +=  arrangementsList[randArrangement][indiciesInOrder[i]].maxTimeString+",";
               displayMinTime += arrangementsList[randArrangement][indiciesInOrder[i]].minTimeString+",";
            }
            fosInput.write(displayName.getBytes());
            fosInput = openFileOutput("minTime.txt", Context.MODE_PRIVATE);
            fosInput.write(displayMinTime.getBytes());
            fosInput = openFileOutput("maxTime.txt", Context.MODE_PRIVATE);
            fosInput.write(displayMaxTime.getBytes());

            Intent intent = new Intent(this, DisplayMessageActivity.class);
            startActivity(intent);
        }catch(FileNotFoundException ex){
        ex.printStackTrace();
        }
        catch (IOException ex){
            ex.printStackTrace();
        }
        catch(NullPointerException ex){
            ex.printStackTrace();
        }
    }
}
